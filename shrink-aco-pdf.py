#!/usr/bin/env python3
#
# Shrink ACO PDF files generated by QNL.
#
# Requires the following tools:
# ImageMagick, poppler, pdf2djvu, ocrodjvu, and hocr-tools
#
# rasan@nyu.edu

from pprint import pformat
import argparse
import functools
import glob
import logging
import math
import os
import PIL.Image
import re
import shutil
import subprocess
import sys
import tempfile
import time


print = functools.partial(print, flush=True)


def do_cmd(cmdlist, **kwargs):
    cmd = list(map(str, cmdlist))
    logging.debug("Running command: %s", " ".join(cmd))
    try:
        process = subprocess.run(cmd, check=True, **kwargs)
    except Exception as e:
        logging.exception(e)
        sys.exit(1)
    return process


def round_down_to_even(num):
    return math.floor(float(num) / 2.0) * 2


def get_img_info(pdf_file):
    ret = do_cmd(
        ["pdfimages", "-l", 1, "-list", pdf_file],
        stdout=subprocess.PIPE,
        universal_newlines=True,
    )
    output = ret.stdout.splitlines()
    logging.debug("pdfimages output: %s", output)
    if len(output) < 3:
        return None

    col_idx = {header: i for i, col in enumerate(output[0].split())}
    logging.debug("column index: %s", pformat(col_idx))

    imgdata = output[2].split()
    ext = {"jpeg": "jpg", "jpx": "jp2"}
    codec = imgdata[col_idx["enc"]]
    dpi = round_down_to_even(imgdata[col_idx["x-ppi"]])
    mask = False
    for line in output[2:]:
        logging.debug(line)
        imgdata = line.split()
        if imgdata[col_idx["type"]] == "mask":
            mask = True
            break
    return {"ext": ext.get(codec), "dpi": dpi, "mask": mask}


def mv(src, dst):
    logging.debug("Moving %s to %s", src, dst)
    shutil.move(src, dst)


def main():
    # Check for required tools
    tools = [
        "convert",
        "djvu2hocr",
        "exiftool",
        "hocr-pdf",
        "pdf2djvu",
        "pdfimages",
        "qpdf",
    ]

    missing = 0
    for prog in tools:
        path = shutil.which(prog)
        if path is None:
            print(f"{prog} not in PATH", file=sys.stderr)
            missing += 1
    if missing > 0:
        sys.exit(1)

    logging.basicConfig(
        format="%(asctime)s - shrink-aco-pdf - %(levelname)s - %(message)s",
        datefmt="%m/%d/%Y %I:%M:%S %p",
    )

    parser = argparse.ArgumentParser(
        description="Shrink ACO PDFs generated by QNL."
    )
    parser.add_argument(
        "input_file", metavar="INPUT_FILE", help="Input PDF file"
    )
    parser.add_argument(
        "output_file", metavar="OUTPUT_FILE", help="Output PDF file"
    )
    parser.add_argument(
        "-d", "--debug", help="Enable debugging messages", action="store_true"
    )
    parser.add_argument(
        "-f",
        "--force",
        help="Force overwrite of output file",
        action="store_true",
    )
    parser.add_argument(
        "--use-existing-hocr",
        action="store_true",
        help="Use existing hOCR files from input directory",
    )
    parser.add_argument(
        "-m",
        "--max-pages",
        type=int,
        default=-1,
        help="Maximum number of pages to process",
    )
    parser.add_argument(
        "--dpi",
        type=int,
        default=72,
        choices=[72, 96, 200],
        help="Resolution for PDF pages",
    )
    args = parser.parse_args()

    if args.debug:
        logging.getLogger().setLevel(logging.DEBUG)

    logging.debug("Input file: %s", args.input_file)
    logging.debug("Output file: %s", args.output_file)

    if args.input_file == args.output_file:
        sys.exit("Input file can't be the same as output file.")

    if not args.force and os.path.exists(args.output_file):
        sys.exit("Output file already exists.")

    input_dir, input_file = os.path.split(args.input_file)
    logging.debug("input dir: %s", input_dir)

    hocr_files = sorted(glob.glob(f"{input_dir}/*_hocr.html"))

    rstar_dir = "/content/prod/rstar"

    aux_exists = False
    objid = os.path.splitext(input_file)[0]
    match = re.search(r"^([a-z]+)_aco\d{6}$", objid)
    if match:
        partner_id = match.group(1)
        aux_dir = f"{rstar_dir}/content/{partner_id}/aco/wip/se/{objid}/aux"
        logging.debug("aux_dir: %s", aux_dir)
        aux_exists = os.path.isdir(aux_dir)

    tmp_rootdir = f"{rstar_dir}/tmp/aco"
    if not os.path.isdir(tmp_rootdir):
        tmp_rootdir = "/tmp"

    # tmpdir = tempfile.TemporaryDirectory(dir=tmp_rootdir)
    # logging.debug("temp directory: %s", tmpdir.name)
    tmpdir = tempfile.mkdtemp(dir=tmp_rootdir)
    logging.debug("temp directory: %s", tmpdir)

    # split pdf into individual pdfs for each page
    do_cmd(
        ["qpdf", "--split-pages", args.input_file, "{}/%d.pdf".format(tmpdir)]
    )

    # Loop over each page until we have an hocr file
    # and reduced jpg for each page
    for i, pdf_file in enumerate(sorted(glob.glob(f"{tmpdir}/*.pdf"))):

        if args.max_pages > 0 and i == args.max_pages:
            break

        imginfo = get_img_info(pdf_file)
        if not imginfo:
            sys.exit(f"Can't find any images in {pdf_file}")
        logging.debug("imginfo: %s", imginfo)
        if imginfo["ext"] is None or imginfo["mask"]:
            img_ext = "png"
            pdfimgs_arg = "-png"
        else:
            img_ext = imginfo["ext"]
            pdfimgs_arg = "-all"

        if i == 0:
            scale_hocr = args.dpi / imginfo["dpi"]
            if imginfo["mask"]:
                scale_hocr *= (4 / 3) * (1 / 2)
            logging.debug("Setting scale for hocr to %s", scale_hocr)

        # set up file paths
        basename = os.path.splitext(pdf_file)[0]
        pdfimgs_dir = os.path.join(tmpdir, "pdfimgs_%03d" % (i + 1))
        pdfimgs_base = os.path.join(pdfimgs_dir, os.path.basename(basename))
        djvu_file = basename + ".djvu"
        hocr_file = basename + ".hocr"
        new_jpg_file = basename + ".jpg"
        old_img_file = pdfimgs_base + "-000." + img_ext

        logging.debug("Creating directory %s", pdfimgs_dir)
        os.mkdir(pdfimgs_dir)

        # extract jpg image from pdf page
        do_cmd(["pdfimages", pdfimgs_arg, pdf_file, pdfimgs_base])

        if imginfo["mask"]:
            bot_layer = old_img_file
            masked = pdfimgs_base + "-001." + img_ext
            old_mask = pdfimgs_base + "-002." + img_ext
            new_mask = pdfimgs_base + "-mask." + img_ext
            top_layer = pdfimgs_base + "-top." + img_ext
            merged = pdfimgs_base + "-merged." + img_ext
            # mask image is twice as large as other images so we
            # must resize it to match them before applying it
            do_cmd(["convert", old_mask, "-resize", "50%", new_mask])
            # apply mask to second image to form top/text layer
            do_cmd([
                "convert",
                masked,
                new_mask,
                "-alpha",
                "Off",
                "-compose",
                "CopyOpacity",
                "-composite",
                top_layer,
            ])
            # merge top/text layer with bottom layer to create
            # final combined image
            do_cmd(["convert", bot_layer, top_layer, "-composite", merged])
            # move merged image so that it can shrunk by
            # imagemagick in step below
            mv(old_img_file, old_img_file + ".bak")
            mv(merged, old_img_file)

        # shrink image size by reducing quality
        do_cmd([
            "convert",
            "-density",
            imginfo["dpi"],
            "-units",
            "PixelsPerInch",
            old_img_file,
            "-resample",
            args.dpi,
            "-density",
            args.dpi,
            "-units",
            "PixelsPerInch",
            new_jpg_file,
        ])

        # Check that shrunken image has correct resolution
        with PIL.Image.open(new_jpg_file) as new_jpg:
            new_jpg_dpi = new_jpg.info["dpi"][0]
        logging.debug("dpi %s: %s", new_jpg_file, new_jpg_dpi)
        if new_jpg_dpi != args.dpi:
            logging.error(
                "Expected dpi %s for %s, found %s instead",
                args.dpi,
                new_jpg_file,
                new_jpg_dpi,
            )
            sys.exit(1)

        # # delete images extracted from pdfimages
        # logging.debug("Removing directory %s", pdfimgs_dir)
        # shutil.rmtree(pdfimgs_dir)

        if args.use_existing_hocr:
            # hocr files seem to shifted by 1
            if i == len(hocr_files) - 1:
                j = 0
            else:
                j = i + 1
            logging.debug("Copying %s to %s", hocr_files[j], hocr_file)
            shutil.copyfile(hocr_files[j], hocr_file)
        else:
            # convert pdf page to djvu file
            do_cmd(["pdf2djvu", "-q", "-o", djvu_file, pdf_file])

            # extract hidden text from djvu file as hocr
            with open(hocr_file, "w") as f:
                ret = do_cmd(
                    ["djvu2hocr", djvu_file], stdout=f, stderr=subprocess.PIPE
                )
                logging.debug(ret.stderr.decode().strip())

        # generating hocr is time consuming so we copy file
        # to aux directory for later use
        if aux_exists:
            dest_file = aux_dir + "/" + os.path.basename(hocr_file)
            if not os.path.isfile(dest_file):
                shutil.copyfile(hocr_file, dest_file)

    # reassemble pdf by combining reduced images
    # and extracted hocr files
    tmp_pdf_file = f"{tmpdir}/tmp.pdf"
    hocr_pdf = [
        "hocr-pdf",
        "--scale-hocr",
        scale_hocr,
        "--savefile",
        tmp_pdf_file,
    ]
    if args.use_existing_hocr:
        hocr_pdf.append("--reverse")
    hocr_pdf.append(tmpdir)
    do_cmd(hocr_pdf)
    do_cmd(["exiftool", "-q", "-m", "-all:all=", tmp_pdf_file])
    do_cmd(["qpdf", "--linearize", tmp_pdf_file, args.output_file])

    logging.debug("Removing directory %s", tmpdir)
    shutil.rmtree(tmpdir)


if __name__ == "__main__":
    main()
